snippet sdoc
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

void read_uint32_t(FILE *__restrict stream, uint32_t *__restrict nr) {
  uint8_t ch;
  *nr = 0;
  while ((ch = fgetc(stream)) && ('0' <= ch && ch <= '9')) {
    *nr *= 10;
    *nr += ch - '0';
  }
  if (ch == '\r') {
    fgetc(stream);
  }
}

int main(void) {
{
	FILE *__restrict in;
#ifdef ONLINE_JUDGE
  in = stdin;
#else
  in = fopen("in", "r");
#endif

  $0

  fclose(in);
}
	
	return 0;
}
endsnippet

snippet pragmas
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("modulo-sched")
endsnippet

snippet readint
void read_$1(FILE *__restrict stream, $1 *__restrict nr) {
	uint8_t ch;
	*nr = 0;
	while ((ch = fgetc(stream)) && ('0' <= ch && ch <= '9')) {
		*nr *= 10;
		*nr += ch - '0';
	}
	if (ch == '\r') {
		fgetc(stream);
	}
}
endsnippet

snippet readinti
void read_$1(FILE *__restrict stream, $1 *__restrict nr) {
	uint8_t ch;
	int8_t sgn = 1;
	*nr = 0;
	ch = fgetc(stream);
	if (ch == '-') {
		sgn = -1;
	} else if (('0' <= ch && ch <= '9')) {
		*nr = ch - '0';
	} else {
		return;
	}
	while ((ch = fgetc(stream)) && ('0' <= ch && ch <= '9')) {
		*nr *= 10;
		*nr += ch - '0';
	}
	if (ch == '\r') {
		fgetc(stream);
	}
	*nr *= sgn;
}
endsnippet

snippet for
{
	int32_t $1;
	for($1 = 0; $1 < $2; ++$1) {
		$0
	}
}
endsnippet

snippet ff
{
	int32_t $1, $3;
	for ($1 = 0; $1 < $2; ++$1) {
		for ($3 = 0; $3 < $4; ++$3) {
			$0
		}
	}
}
endsnippet

snippet fff
{
	int32_t $1, $3, $5;
	for ($1 = 0; $1 < $2; ++$1) {
		for ($3 = 0; $3 < $4; ++$3) {
			for ($5 = 0; $5 < $6; ++$5) {
				$0
			}
		}
	}
}
endsnippet

snippet include
#include <$1>$0
endsnippet

snippet bitset "Add bitset functionality"
typedef uint8_t bitset;
void __inline__ bits_set(bitset *bs, uint32_t pos) { bs[pos/8]|=(1<<(pos%8)); }
uint8_t __inline__ bits_get(bitset *bs, uint32_t pos) { return (bs[pos/8]>>(pos%8)) & 1; }
$0
endsnippet

snippet *_r "*__restrict"
*__restrict $0
endsnippet

snippet maxf "Max Function"
$1 __inline__ __attribute((pure)) max($1 o1, $1 o2) { return o1 > o2 ? o1 : o2; }$0
endsnippet

snippet minf "Min Function"
$1 __inline__ __attribute((pure)) min($1 o1, $1 o2) { return o1 < o2 ? o1 : o2; }$0
endsnippet

snippet lpow "Logarithmic Exponentiation"
$1 lpow($1 b, $1 exp) {
  $1 r = 1;
  if (exp == 0) {
    return r;
  }
  while (exp != 0) {
    if ((exp & 1) == 1) {
      r *= b;
    }
    exp >>= 1;
    b *= b;
  }
	if (r == 0) {
		return -1;
	}
  return r;
}$0
endsnippet

snippet lpowm "Logarithmic Exponentiation With Modulo"
$1 lpowm($1 b, $1 exp, $1 mod) {
  $1 r = 1;
  b %= mod;
  if (exp == 0) {
    return r;
  }
  while (exp != 0) {
    if ((exp & 1) == 1) {
      r *= b;
      r %= mod;
    }
    exp >>= 1;
    b *= b;
    b %= mod;
  }
  if (r == 0) {
    return -1;
  }
  return r;
}$0
endsnippet

snippet nth "Nth root of a number, rounded down to nearest int"
$1 nroot($1 nr, $1 n) {
  if (n == 0) {
    return 0;
  }
  if (n == 1) {
    return nr;
  }
  $1 v = 1, bit, tp, t;
  tp = lpow(v, n);

  while (tp < nr) {
    v <<= 1;
    tp = lpow(v, n);
  }

  if (tp == nr) {
    return v;
  }

  v >>= 1;
  bit = v >> 1;
  tp = lpow(v, n);
  while (nr > tp) {
    v += bit;
    t = lpow(v, n);
    if (t > nr) {
      v -= bit;
    } else {
      tp = t;
    }
    if ((bit >>= 1) == 0) {
      break;
    }
  }
  return v;
}$0
endsnippet

snippet bsearch "Not sure if it works"
$1 bsrc($1 *__restrict vec, $1 lbound, $1 ubound, $1 threshold) {
  $1 cpos;
  $1 answer = lbound;
  while (lbound <= ubound) {
    cpos = (ubound + lbound) / 2;
    if (vec[cpos] <= threshold) {
      answer = cpos;
      lbound = cpos + 1;
    } else {
      ubound = cpos - 1;
    }
  }
  return answer;
}$0
endsnippet

snippet file "Read/Write template"
{
	FILE *__restrict $1 = fopen("$2", "$3");

	$0

	fclose($1);
}
endsnippet

snippet ciurf "Erathostene's sieve"
void mkciur(bitset *__restrict vec, $1 lim) {
  $1 i, j;
  $1 sqlim = sqrt(lim);
  bits_set(vec, 0);
  bits_set(vec, 1);
  for(i = 4; i <= lim; i+=2) {
    bits_set(vec, i);
  }
  for(i = 9; i <= lim; i+=3) {
    bits_set(vec, i);
  }
  for(i = 1; (6*i-1) <= sqlim; ++i) {
    if (bits_get(vec,6*i-1) == 0) {
      for(j = 36*(i*i) - 12*i + 1; j <= lim; j += (12*i-2)) { // (6i-1)^2 
        bits_set(vec, j);
      }
    }
    if ((6*i+1) <= sqlim && bits_get(vec,6*i+1) == 0) {
      for(j = 36*(i*i) + 12*i + 1; j <= lim; j += (12*i+2)) { // (6i+1)^2 
        bits_set(vec, j);
      }
    }
  }
}
endsnippet

snippet gcdf "Greatest common divisor"
$1 gcd($1 o1, $1 o2) {
  $1 t;
  while (o2 != 0) {
    t = o2;
    o2 = o1 % o2;
    o1 = t;
  }
  return o1;
}$0
endsnippet

snippet lcmf "Least common multiple"
$1 lcm($1 o1, $1 o2) {
  return o1 * o2 / gcd(o1, o2);
}
endsnippet

snippet queue "Queue boilerplate"
#define QUEUES $2
struct queue { $1 q[QUEUES]; int32_t st; int32_t ed; };
void ppop(struct queue *__restrict q) { ++q->st; q->st %= QUEUES; }
$1 ptop(struct queue *__restrict q) { return q->q[q->st]; }
void ppush(struct queue *__restrict q, $1 val) { q->q[q->ed] = val; ++q->ed; q->ed %= QUEUES; }
struct queue q;
endsnippet

snippet dequef "Deque boilerplate"
#define DEQUES $2
struct deque { $1 q[DEQUES]; int32_t st; int32_t ed; };
void popback(struct deque *__restrict q) { ++q->st; q->st %= DEQUES; }
void popfront(struct deque *__restrict q) { --q->ed; if (q->ed == -1) { q->ed = DEQUES - 1; } }
$1 dback(struct deque *__restrict q) { return q->q[q->st]; }
$1 dfront(struct deque *__restrict q) { return q->q[q->ed]; }
void pushfront(struct deque *__restrict q, $1 val) { q->q[q->ed] = val; ++q->ed; q->ed %= DEQUES; }
void pushback(struct deque *__restrict q, $1 val) { --q->st; if (q->st == -1) { q->st = DEQUES - 1; } q->q[q->st] = val; }
struct dequeue q;
endsnippet

snippet msbf "Most significant bit"
$1 msb($1 nr) { nr |= nr >> 1; nr |= nr >> 2; nr |= nr >> 4;  nr |= nr >> 8; nr |= nr >> 16; nr += 1; return (nr >> 1); }$0
endsnippet

snippet stack "Stack boilerplate"
struct stack {
  $1 v[$2];
  uint32t vl;
};
$1 stop(struct stack *__restrict s) {
  return s->v[s->vl-1];
}
void spop(struct stack *__restrict s) {
    --s->vl;
}
void spush(struct stack *__restrict s, $1 val) {
  s->v[s->vl] = val;
  ++s->vl;
}
endsnippet

snippet fsumdivston "Sum of divisors of all numbers from 1 to n"
$1 sum_all_divisors($1 num)
{
    $1 sum = 0;
		$1 i;
		$1 sqn = sqrt(num);
    for (i = 1; i <= sqn; ++i{
        $1 t1 = i * (num / i - i + 1);
        $1 t2 = (((num / i) * (num / i + 1)) / 2) - ((i * (i + 1)) / 2);
        sum += t1 + t2;
    }
    return sum;
}
endsnippet

snippet vecf "Dynamic vector"
struct vec { size_t mlen; size_t clen; $1 *__restrict v; };
void vpush(struct vec *__restrict v, $1 val) { if (v->clen == v->mlen) { v->mlen *= 2; v->v = realloc(v->v, (v->mlen) * sizeof(v->v[0])); } v->v[v->clen] = val; ++v->clen; }
struct vec initv(size_t len) { struct vec res = {0}; res.mlen = len; res.v = malloc(len * sizeof(res.v[0])); return res; }
$0
endsnippet

snippet cmpf
int cmp(const void *o1, const void *o2) { /// \`>\` means ascending; \`<\` means descending
  return (*($1 *)o1) $2 (*($1 *)o2);
}$0
endsnippet

snippet ephi
$1 ephi($1 x) {
  $1 sqx = sqrt(x);
  $1 res = x;
  int32_t i;
  for(i = 2; i <= sqx; ++i) {
    if (x % i == 0) {
      while (x % i == 0) {
        x /= i;
      }
      res -= res / i;
    }
  }
  if (x != 1) {
    res -= res / x;
  }
  return res;
}$0
endsnippet

snippet rmq
$1 rmq[17][$2];
uint8_t l[$2];

void build_rmq(uint32_t x) {
  int32_t i, j;
  uint32_t cp = 0;
  for(i = 1; i <= 16; ++i) {
    cp = 1 << (i - 1);
    for(j = cp; j < x; ++j) {
      rmq[i][j] = gcd(rmq[i-1][j], rmq[i-1][j-cp]);
    }
  }
}

void build_log(uint32_t x) {
  l[0] = 0;
  l[1] = 0;
  int32_t i;
  for(i = 2; i <= x; ++i) {
    l[i] = l[i>>1] + 1;
  }
}

$1 grmq($1 x, $1 y) {
  $1 dif = y - x + 1;
  return gcd(rmq[l[dif]][y], rmq[l[dif]][x + (1 << l[dif]) - 1]);
}
endsnippet

snippet pure
__attribute((pure))$0
endsnippet

snippet cfile
{
	FILE *__restrict in;
#ifdef ONLINE_JUDGE
		in = stdin;
#else
		in = fopen("in", "r");
#endif

	$0

	fclose(in);
}
endsnippet

snippet manacher "Manacher's algorithm"
void manacher_odd(char *s, uint32_t sl, uint32_t *mana) { /// The string must be altered to begin with $, and with ^ and contain # between every character
    int32_t l, r;
		int32_t i;
		l = r = 1;
    for(i = 1; i <= sl; i++) {
        mana[i] = max(0, min(r - i, mana[l + (r - i)]));
        while(s[i - mana[i]] == s[i + mana[i]]) {
            mana[i]++;
        }
        if(i + mana[i] > r) {
            l = i - mana[i], r = i + mana[i];
        }
    }
endsnippet

snippet sosdp
{
	int32_t i;
	int32_t mask;
	for(i = 0; i < (1<<n); ++i) {
		f[i] = a[i];
	}
	for(i = 0; i < n; ++i) {
		for(mask = 0; mask < (1<<n); ++mask) {
			if(mask & (1<<i)) {
				f[mask] += f[mask^(1<<i)];
			}
		}
	}
}
endsnippet

snippet segt "Needs improvement segment trees"
$1 {
	$0
};

uint32_t a[$2];
$1 b[4 * $2];

$1 mkp(int32_t x) {
  $1 r = {0};
  return r;
}

$1 combine($1 o1, $1 o2) {
  $1 r = {0};
  return r;
}

void build(int32_t p, int32_t tl, int32_t tr) { /// build(1, 1, n);
#define ND b[p * 2]
#define NU b[p * 2 + 1]
  if (tl == tr) {
    b[p] = mkp(a[tl]);
  } else {
    int32_t tm = (tl + tr) / 2;
    build(p * 2    , tl    , tm);
    build(p * 2 + 1, tm + 1, tr);
    b[p] = combine(ND, NU);
  }
}

void update(int32_t p, int32_t tl, int32_t tr, int32_t pos, int32_t v) {
  if (tl == tr) {
    b[p] = mkp(v);
  } else {
    int32_t tm = (tl + tr) / 2;
    if (pos <= tm) {
      update(p * 2    , tl    , tm, pos, v);
    } else {
      update(p * 2 + 1, tm + 1, tr, pos, v);
    }
    b[p] = combine(ND, NU);
  }
#undef ND
#undef NU
}

$1 query(int32_t p, int32_t tl, int32_t tr, int32_t l, int32_t r) {
  if (l > r) {
    return mkp(0);
  }
  if (l <= tl && tr <= r) {
    return b[p];
  }
  int32_t tm = (tl + tr) / 2;
  $1 rs = {0};
  $1 rd = {0};
  if (l <= tm) {
    rs = query(p * 2    , tl     , tm, l, r);
  }
  if (tm + 1 <= r) {
    rd = query(p * 2 + 1, tm + 1, tr, l, r);
  }
  return combine(rs, rd);
}
endsnippet

snippet reads
void reads(FILE *__restrict file, char *__restrict s, uint32_t *__restrict sl) {
  uint32_t t;
  if (sl == NULL) { sl = &t; }
  *sl = 0;
  while ((s[*sl] = fgetc(file)) && (('a' <= s[*sl] && s[*sl] <= 'z') || ('A' <= s[*sl] && s[*sl] <= 'Z'))) {
    ++*sl;
  }
  if (s[*sl] == '\r') { fgetc(file); }
  s[*sl] = '\0';
}
$0
endsnippet

snippet U32f "Cursed U32 reading"
void read_uint32_t(FILE *__restrict stream,uint32_t *__restrict nr){uint8_tch;*nr=0;while((ch=fgetc(stream))&&('0'<=ch&&ch<='9')){*nr*=10;*nr+=ch-'0';}if(ch=='\r'){fgetc(stream);}}
void _U32(FILE *__restrict stream, uint32_t count, ...){va_list val;va_start(val,stream);int32_t i; for(i=0;i<count;++i){read_uint32_t(va_arg(val,uint32_t *__restrict);}}
#define VA_LENGTH_(_0,_1,_2,_3,_4,_5,_6,_7,_8,N,...) N
#define VA_LENGTH(...) VA_LENGTH_(0, ## __VA_ARGS__,8,7,6,5,4,3,2,1,0)
#define U32(stream, ...) _U32(stream, VA_LENGTH(__VA_ARGS__), __VA_ARGS__)
$0
endsnippet

snippet dsuf
uint32_t p[$1], s[$1];
void mset(uint32_t v) { p[v] = v; s[v] = 1; }
uint32_t fset(uint32_t v) { if (v == p[v]) { return v; } return p[v] = fset(p[v]); }
uint32_t uset(uint32_t a, uint32_t b) { a = fset(a); b = fset(b); if (a != b) { if (s[a] < s[b]) { p[a] = b; s[b] += s[a]; return b; } else { p[b] = a; s[a] += s[b]; return a;} } return UINT32_MAX; }
$0
endsnippet

snippet fenwickf "Hope this works"
uint32_t fw[$1];
void add(uint32_t i, uint32_t d) { while (i < n) { fw[i] += d; i |= (i + 1) } }
void cfwt(uint32_t *__restrict v) { int32_t i; for(i = 0; i < n; ++i) { add(i, v[i]); } }
uint32_t sum(int32_t r) { uint32_t ret = 0; while (r >= 0) { ret += fw[r]; r = (r & (r + 1)) - 1} } return ret; }
$0
endsnippet

snippet fen2f "Hope this works^2"
uint32_t fw[$1][$1];
uint32_t sum(uint32_t x, uint32_t y) { if (x == -1 || y == -1) { return 0; } uint32_t ret = 0; int32_t i, j;  for (i = x; i >= 0; i = (i & (i + 1)) - 1) {  for (j = y; j >= 0; j = (j & (j + 1)) - 1) { ret += fw[i][j]; } } return ret; }
void add(uint32_t x, uint32_t y, uint32_t d) { uint32_t i, j; for (i = x; i < n; i |= i + 1) { for (j = y; j < m; j |= j + 1) { fw[i][j] += d; } } }
$0
endsnippet

snippet pfuncf "Prefix function, was too nice to compactify" 
uint32_t pi[$1];
void pifunction(char *__restrict s, uint32_t sl) {
  uint32_t i, j;
  for (i = 1; i < sl; i++) {
    j = pi[i - 1];
    while (j > 0 && s[i] != s[j]) { j = pi[j - 1]; }
    if (s[i] == s[j]) { j++; }
    pi[i] = j;
  }
}
$0
endsnippet

snippet dinic "Why is this so fucking long"
#define QUEUES $1
struct queue { int32_t q[QUEUES]; int32_t st; int32_t ed; };
void pop(struct queue *__restrict q) { ++q->st; q->st %= QUEUES; }
int32_t top(struct queue *__restrict q) { return q->q[q->st]; }
void push(struct queue *__restrict q, int32_t val) { q->q[q->ed] = val; ++q->ed; q->ed %= QUEUES; }

struct flow_edge {
    int32_t v, u;
    int64_t cap, flow;
};
struct flow_edge edges[$1 * $1];
uint32_t edgesl = 0;
uint8_t adj[$1][$1];
uint32_t adjl[$1];
int32_t level[$1];
int32_t ptr[$1];
struct queue q;
int32_t s, t;

void add_edge(int32_t v, int32_t u, int64_t cap) {
  edges[edgesl] = (struct flow_edge) { v, u, cap, 0 };
  adj[v][adjl[v]++] = edgesl++;
  edges[edgesl] = (struct flow_edge) { u, v, 0, 0 };
  adj[u][adjl[u]++] = edgesl++;
}

uint8_t dbfs() {
  int32_t i;
  int32_t v;
  while (q.st != q.ed) {
    v = top(&q);
    pop(&q);
    for (i = 0; i < adjl[v]; ++i) {
#define CID adj[v][i]
      if ((edges[CID].cap - edges[CID].flow < 1) || (level[edges[CID].u] != -1)) { continue; }
      level[edges[CID].u] = level[v] + 1;
      push(&q, edges[CID].u);
#undef CID
    }
  }
  return level[t] != -1;
}

int64_t ddfs(int32_t v, int64_t pushed) {
  int32_t id, u, tr;
  if ((v == t) || (pushed == 0)) { return pushed; } 
  while (ptr[v] < adjl[v]) {
    id = adj[v][ptr[v]++];
    u = edges[id].u;
    if ((level[v] + 1 != level[u]) || (edges[id].cap - edges[id].flow < 1)) { continue; }
    tr = ddfs(u, min(pushed, edges[id].cap - edges[id].flow));
    if (tr == 0) { continue; }
    edges[id    ].flow += tr;
    edges[id ^ 1].flow -= tr;
    return tr;
  }
  return 0;
}

int64_t flow() {
  int64_t f = 0, pushed;
  while (1) {
    memset(level, 0xFF, sizeof(level));
    level[s] = 0;
    push(&q, s);
    if (!dbfs()) { break; }
    memset(ptr, 0, sizeof(ptr));
    while ((pushed = ddfs(s, INT64_MAX))) { f += pushed; }
  }
  return f;
}
$0
endsnippet

snippet swapf "Daca tot cereai tu Rares"
$1 swap($1 *__restrict o1, $1 *__restrict o2) { $1 t = *o1; *o1 = *o2; *o2 = t; }
endsnippet

snippet lichaof "This alone is 3kb"
int32_t __inline__ __attribute((pure)) max(int32_t o1, int32_t o2) { return o1 > o2 ? o1 : o2; }
struct line { int32_t a, b; }; /// Esti intersectia dintre cercuri
int32_t lget(struct line l, int32_t x) { return l.a * x + l.b; }
struct line ladd(struct line o1, struct line o2) { return (struct line) { o1.a + o2.a, o1.b + o2.b }; }
void swap(struct line *__restrict o1, struct line *__restrict o2) { struct line t = *o1; *o1 = *o2; *o2 = t; }

struct node { struct line line, lazy; struct node *__restrict lc, *__restrict rc; };
struct node *__restrict initn() { struct node *__restrict n = calloc(sizeof(struct node), 1); n->line = (struct line) {0, INT32_MIN}; return n; }
void apply(struct node *__restrict n, struct line v) { n->line = ladd(n->line, v); n->lazy = ladd(n->lazy, v); }
struct node *__restrict root;

void push_lazy(struct node *__restrict *__restrict n, int32_t tl, int32_t tr) {
  if (!*n) { return; } if (!(*n)->lc) { (*n)->lc = initn(); } if (!(*n)->rc) { (*n)->rc = initn(); }
  apply((*n)->lc, (*n)->lazy); 
  apply((*n)->rc, (*n)->lazy);
  (*n)->lazy = (struct line) {0};
}

void insert_linek(struct node *__restrict *__restrict n, int32_t tl, int32_t tr, struct line x);
void push_line(struct node *__restrict *__restrict n, int32_t tl, int32_t tr) {
  if (!*n) { return; }
  int32_t mid = (tl + tr) / 2;
  insert_linek(&(*n)->lc, tl, mid, (*n)->line); 
  insert_linek(&(*n)->rc, mid + 1, tr, (*n)->line);
  (*n)->line = (struct line) {0, INT32_MIN};
}

void insert_linek(struct node *__restrict *__restrict n, int32_t tl, int32_t tr, struct line x) {
  if (!*n) { *n = initn(); } /// LOOK HERE If you wanna modify its behaviour
  if (lget((*n)->line, tl) < lget(x, tl)) { swap(&(*n)->line, &x); }
  if (lget((*n)->line, tr) >= lget(x, tr)) { return; }
  if (tl == tr) { return; }
  int32_t mid = (tl + tr) / 2;
  push_lazy(n, tl, tr);
  if (lget((*n)->line, mid) > lget(x, mid)) { insert_linek(&(*n)->rc, mid + 1, tr, x); } 
  else { swap(&(*n)->line, &x); insert_linek(&(*n)->lc, tl, mid, x); }
}

void insert_line(struct node *__restrict *__restrict n, int32_t tl, int32_t tr, int32_t l, int32_t r, struct line x) { /// insert_line(&root, 0, n - 1, l, r, line);
  if (tr < l || r < tl || tl > tr || l > r) { return; }
  if (!*n) { *n = initn(); }
  if (l <= tl && tr <= r) { return insert_linek(n, tl, tr, x); }
  int32_t mid = (tl + tr) / 2;
  push_lazy(n, tl, tr);
  insert_line(&(*n)->lc, tl, mid, l, r, x);
  insert_line(&(*n)->rc, mid + 1, tr, l, r, x);
}

void add_line(struct node *__restrict *__restrict n, int32_t tl, int32_t tr, int32_t l, int32_t r, struct line x) { /// add_line(&root, 0, n - 1, l, r, line);
  if (tr < l || r < tl || tl > tr || l > r) { return; }
  if (!*n) { *n = initn(); }
  if (l <= tl && tr <= r) { return apply(*n, x); }
  int32_t mid = (tl + tr) / 2;
  push_lazy(n, tl, tr);
  push_line(n, tl, tr);
  add_line(&(*n)->lc, tl, mid, l, r, x);
  add_line(&(*n)->rc, mid + 1, tr, l, r, x);
}

int32_t query(struct node *__restrict *__restrict n, int32_t tl, int32_t tr, int32_t x) {
  if (!*n) { return INT32_MAX; }
  if (tl == tr) { return lget((*n)->line, x); }
  int32_t res = lget((*n)->line, x);
  int32_t mid = (tl + tr) / 2;
  push_lazy(n, tl, tr);
  if (x <= mid) { res = max(res, query(&(*n)->lc, tl, mid, x)); } 
  else { res = max(res, query(&(*n)->rc, mid + 1, tr, x)); }
  return res;
} 
$0
endsnippet
